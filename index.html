<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LeetCode Test Case Generator</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            background-color: #fafafa;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid #e5e5e5;
        }

        header h1 {
            color: #2c3e50;
            font-size: 2.2rem;
            margin: 0 0 0.5rem 0;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        header p {
            color: #666;
            font-size: 1rem;
            margin: 0;
            font-weight: 400;
        }

        .card {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #2c3e50;
            font-size: 0.95rem;
        }

        textarea {
            width: 100%;
            min-height: 200px;
            padding: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            resize: vertical;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background-color: #fafafa;
        }

        textarea:focus {
            outline: none;
            border-color: #6b7280;
            box-shadow: 0 0 0 3px rgba(107, 114, 128, 0.1);
            background-color: white;
        }

        .language-selector {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            overflow: hidden;
        }

        .language-option {
            flex: 1;
        }

        .language-option input[type="radio"] {
            display: none;
        }

        .language-option label {
            display: block;
            padding: 0.75rem 1rem;
            background: white;
            border-right: 1px solid #d1d5db;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            margin: 0;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .language-option:last-child label {
            border-right: none;
        }

        .language-option input[type="radio"]:checked + label {
            background: #f3f4f6;
            color: #2c3e50;
        }

        .language-option label:hover {
            background: #f9fafb;
        }

        .generate-btn {
            width: 100%;
            padding: 0.875rem 2rem;
            font-size: 0.95rem;
            font-weight: 500;
            color: white;
            background: #2c3e50;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .generate-btn:hover {
            background: #34495e;
        }

        .generate-btn:active {
            background: #1a252f;
        }

        .generate-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #6b7280;
        }

        .output-section {
            display: none;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e5e5e5;
        }

        .output-header h2 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .copy-btn {
            padding: 0.5rem 1rem;
            background: #f3f4f6;
            color: #374151;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .copy-btn:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }

        .copy-btn.copied {
            background: #d1fae5;
            color: #065f46;
            border-color: #a7f3d0;
        }

        pre {
            background: #f8f9fa;
            border: 1px solid #e5e5e5;
            padding: 1.5rem;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 13px;
            line-height: 1.5;
            margin: 0;
            color: #2d3748;
        }

        .error-message {
            background: #fef2f2;
            color: #dc2626;
            padding: 1rem;
            border-radius: 6px;
            border-left: 3px solid #ef4444;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .success-message {
            background: #f0fdf4;
            color: #16a34a;
            padding: 1rem;
            border-radius: 6px;
            border-left: 3px solid #22c55e;
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        .info-box {
            background: #f8fafc;
            color: #475569;
            padding: 1rem;
            border-radius: 6px;
            border-left: 3px solid #94a3b8;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 0.5rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .stat-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e5e5;
        }

        .stat-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .instructions {
            background: white;
            border: 1px solid #e5e5e5;
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 2rem;
        }

        .instructions h3 {
            margin: 0 0 1rem 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
        }

        .instructions ol {
            margin: 0;
            padding-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #4b5563;
        }

        .keyboard-hint {
            font-size: 0.8rem;
            color: #6b7280;
            text-align: center;
            margin-top: 0.5rem;
        }

        .keyboard-hint kbd {
            background: #f3f4f6;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            padding: 0.1rem 0.3rem;
            font-size: 0.75rem;
            font-family: monospace;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            header h1 {
                font-size: 1.8rem;
            }

            .language-selector {
                flex-direction: column;
            }

            .language-option label {
                border-right: none;
                border-bottom: 1px solid #d1d5db;
            }

            .language-option:last-child label {
                border-bottom: none;
            }

            .output-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }
        }

        /* Syntax highlighting for code */
        .keyword { color: #0066cc; }
        .string { color: #008000; }
        .comment { color: #808080; font-style: italic; }
        .number { color: #ff6600; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>LeetCode Test Generator</h1>
            <p>Generate clean test boilerplate code from LeetCode problems</p>
        </header>

        <div class="card">
            <div class="info-box">
                <strong>Instructions:</strong> Navigate to any LeetCode problem page, right-click and select "View Page Source", copy all content (Ctrl+A, Ctrl+C), then paste it below.
            </div>

            <div class="form-group">
                <label for="sourceCode">LeetCode Page Source</label>
                <textarea
                    id="sourceCode"
                    placeholder="Paste the complete HTML source code from LeetCode problem page here..."
                    spellcheck="false"
                ></textarea>
            </div>

            <div class="form-group">
                <label>Programming Language</label>
                <div class="language-selector">
                    <div class="language-option">
                        <input type="radio" id="cpp" name="language" value="cpp" checked>
                        <label for="cpp">C++</label>
                    </div>
                    <div class="language-option">
                        <input type="radio" id="python" name="language" value="python">
                        <label for="python">Python</label>
                    </div>
                    <div class="language-option">
                        <input type="radio" id="java" name="language" value="java">
                        <label for="java">Java</label>
                    </div>
                </div>
            </div>

            <button class="generate-btn" onclick="generateCode()" id="generateBtn">
                Generate Test Code
            </button>

            <div class="keyboard-hint">
                Press <kbd>Ctrl</kbd> + <kbd>Enter</kbd> to generate
            </div>

            <div id="messageContainer"></div>
        </div>

        <div class="card output-section" id="outputSection">
            <div class="output-header">
                <h2>Generated Test Code</h2>
                <button class="copy-btn" onclick="copyCode()" id="copyBtn">Copy Code</button>
            </div>

            <div id="statsContainer"></div>

            <pre><code id="outputCode"></code></pre>
        </div>

        <div class="instructions">
            <h3>How to Use</h3>
            <ol>
                <li>Open any LeetCode problem page in your browser</li>
                <li>Right-click anywhere on the page and select "View Page Source"</li>
                <li>Select all content using Ctrl+A (or Cmd+A on Mac)</li>
                <li>Copy the content using Ctrl+C (or Cmd+C on Mac)</li>
                <li>Paste the source code into the textarea above</li>
                <li>Choose your preferred programming language</li>
                <li>Click "Generate Test Code" or use Ctrl+Enter</li>
                <li>Copy the generated code and test your solution locally</li>
            </ol>
        </div>
    </div>

    <script>
        class LeetCodeParser {
            constructor() {
                this.supportedLanguages = {
                    cpp: new CppGenerator(),
                    python: new PythonGenerator(),
                    java: new JavaGenerator()
                };
            }

            async generateCode() {
                const sourceCode = document.getElementById('sourceCode').value.trim();
                const selectedLanguage = document.querySelector('input[name="language"]:checked').value;

                if (!sourceCode) {
                    this.showMessage('Please paste the LeetCode page source code.', 'error');
                    return;
                }

                this.showLoading(true);
                this.clearMessages();

                try {
                    const problemData = this.extractProblemData(sourceCode);
                    const generator = this.supportedLanguages[selectedLanguage];
                    const generatedCode = generator.generate(problemData);

                    this.displayResult(generatedCode, problemData);
                    this.showMessage('Code generated successfully!', 'success');

                } catch (error) {
                    console.error('Generation error:', error);
                    this.showMessage(`Error: ${error.message}`, 'error');
                } finally {
                    this.showLoading(false);
                }
            }

            extractProblemData(htmlString) {
                try {
                    const doc = new DOMParser().parseFromString(htmlString, 'text/html');
                    const scriptTag = doc.getElementById('__NEXT_DATA__');

                    if (!scriptTag) {
                        throw new Error('Could not find __NEXT_DATA__ script tag. Make sure you copied the complete page source.');
                    }

                    const jsonData = JSON.parse(scriptTag.textContent);
                    const queries = jsonData.props?.pageProps?.dehydratedState?.queries;

                    if (!queries || !Array.isArray(queries)) {
                        throw new Error('Invalid page structure. Please ensure you copied from a LeetCode problem page.');
                    }

                    const questionQuery = queries.find(q =>
                        q.queryKey && q.queryKey[0] === 'questionDetail'
                    );

                    if (!questionQuery?.state?.data?.question) {
                        throw new Error('Could not find question data. Please verify the page source is from a LeetCode problem.');
                    }

                    const questionData = questionQuery.state.data.question;
                    const metaData = JSON.parse(questionData.metaData);

                    // Extract test cases more robustly
                    const examples = questionData.exampleTestcaseList || [];
                    const outputs = this.extractExpectedOutputs(questionData.content);

                    return {
                        title: questionData.questionTitle,
                        titleSlug: questionData.titleSlug,
                        difficulty: questionData.difficulty,
                        functionName: metaData.name,
                        returnType: metaData.return.type,
                        parameters: metaData.params,
                        examples: examples,
                        expectedOutputs: outputs,
                        content: questionData.content
                    };

                } catch (error) {
                    if (error.message.includes('JSON')) {
                        throw new Error('Failed to parse page data. The page structure might have changed.');
                    }
                    throw error;
                }
            }

            extractExpectedOutputs(content) {
                const outputs = [];
                const outputRegex = /<strong>Output:<\/strong>.*?<span class="example-io">(.*?)<\/span>/gs;
                let match;

                while ((match = outputRegex.exec(content)) !== null) {
                    outputs.push(match[1].trim());
                }

                // Fallback: try different patterns
                if (outputs.length === 0) {
                    const altRegex = /<strong>Output:<\/strong>\s*([^\n<]+)/gs;
                    while ((match = altRegex.exec(content)) !== null) {
                        outputs.push(match[1].trim());
                    }
                }

                return outputs;
            }

            displayResult(code, problemData) {
                document.getElementById('outputCode').textContent = code;
                document.getElementById('outputSection').style.display = 'block';

                // Show statistics
                const statsHtml = `
                    <div class="stats">
                        <div class="stat-item">
                            <div class="stat-value">${problemData.title}</div>
                            <div class="stat-label">Problem</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${problemData.difficulty}</div>
                            <div class="stat-label">Difficulty</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${problemData.examples.length}</div>
                            <div class="stat-label">Test Cases</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value">${problemData.parameters.length}</div>
                            <div class="stat-label">Parameters</div>
                        </div>
                    </div>
                `;
                document.getElementById('statsContainer').innerHTML = statsHtml;

                // Scroll to output
                document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });
            }

            showMessage(message, type) {
                const container = document.getElementById('messageContainer');
                const messageClass = type === 'error' ? 'error-message' : 'success-message';
                container.innerHTML = `<div class="${messageClass}">${message}</div>`;
            }

            clearMessages() {
                document.getElementById('messageContainer').innerHTML = '';
            }

            showLoading(show) {
                const btn = document.getElementById('generateBtn');
                if (show) {
                    btn.innerHTML = '<span class="loading"></span>Generating...';
                    btn.disabled = true;
                } else {
                    btn.innerHTML = 'Generate Test Code';
                    btn.disabled = false;
                }
            }
        }

        class CppGenerator {
            generate(problemData) {
                const { title, titleSlug, functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                let code = `// Generated by LeetCode Test Generator
// Problem: ${title}
// Link: https://leetcode.com/problems/${titleSlug}/

#include <bits/stdc++.h>
using namespace std;

${this.generateHelperFunctions()}

${this.generateStructDefinitions(returnType, parameters)}

class Solution {
public:
    ${this.mapTypeToCpp(returnType)} ${functionName}(${this.generateParameterList(parameters)}) {
        // TODO: Implement your solution here
        return ${this.getDefaultValue(returnType)};
    }
};

${this.generateTestMain(problemData)}`;

                return code;
            }

            generateHelperFunctions() {
                return `// Helper Functions
string trim(const string& str) {
    size_t first = str.find_first_not_of(" \\t\\n\\r");
    if (string::npos == first) return "";
    size_t last = str.find_last_not_of(" \\t\\n\\r");
    return str.substr(first, (last - first + 1));
}

vector<int> parseVectorInt(string input) {
    vector<int> result;
    input = trim(input);
    if (input.length() < 2) return result;
    input = input.substr(1, input.length() - 2);
    if (input.empty()) return result;
    stringstream ss(input);
    string item;
    while (getline(ss, item, ',')) {
        result.push_back(stoi(trim(item)));
    }
    return result;
}

vector<string> parseVectorString(string input) {
    vector<string> result;
    input = trim(input);
    if (input.length() < 2) return result;
    input = input.substr(1, input.length() - 2);
    if (input.empty()) return result;
    stringstream ss(input);
    string item;
    bool inQuotes = false;
    string current = "";
    for (char c : input) {
        if (c == '"') inQuotes = !inQuotes;
        else if (c == ',' && !inQuotes) {
            result.push_back(trim(current).substr(1, trim(current).length() - 2));
            current = "";
        } else {
            current += c;
        }
    }
    if (!current.empty()) {
        result.push_back(trim(current).substr(1, trim(current).length() - 2));
    }
    return result;
}

template<typename T>
void printVector(const vector<T>& vec) {
    cout << "[";
    for (size_t i = 0; i < vec.size(); ++i) {
        cout << vec[i] << (i == vec.size() - 1 ? "" : ", ");
    }
    cout << "]";
}

template<typename T>
bool compareVectors(const vector<T>& a, const vector<T>& b) {
    if (a.size() != b.size()) return false;
    for (size_t i = 0; i < a.size(); ++i) {
        if (a[i] != b[i]) return false;
    }
    return true;
}`;
            }

            generateStructDefinitions(returnType, parameters) {
                const needsListNode = returnType.includes('ListNode') ||
                                    parameters.some(p => p.type.includes('ListNode'));
                const needsTreeNode = returnType.includes('TreeNode') ||
                                    parameters.some(p => p.type.includes('TreeNode'));

                let structs = '';

                if (needsListNode) {
                    structs += `
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};`;
                }

                if (needsTreeNode) {
                    structs += `
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};`;
                }

                return structs;
            }

            generateParameterList(parameters) {
                return parameters.map(p => {
                    const cppType = this.mapTypeToCpp(p.type);
                    if (cppType.startsWith("vector") || cppType.startsWith("string")) {
                        return `const ${cppType}& ${p.name}`;
                    }
                    return `${cppType} ${p.name}`;
                }).join(", ");
            }

            generateTestMain(problemData) {
                const { functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                let mainCode = `
int main() {
    Solution sol;
    const int TIME_LIMIT_MS = 2000; // 2 seconds
    int passed = 0, total = ${examples.length};

    cout << "Running ${examples.length} test cases...\\n" << endl;`;

                examples.forEach((example, i) => {
                    const inputs = example.split('\n');
                    const expectedOutput = expectedOutputs[i] || "null";

                    mainCode += `
    // Test Case ${i + 1}
    {
        cout << "--- Test Case ${i + 1} ---" << endl;`;

                    let callParams = [];
                    let inputSetup = "";

                    inputs.forEach((inputLine, j) => {
                        if (j >= parameters.length) return;

                        const param = parameters[j];
                        const paramType = this.mapTypeToCpp(param.type);
                        const varName = `${param.name}_${i + 1}`;
                        callParams.push(varName);

                        const cleanInput = inputLine.replace(/\r/g, '').trim();

                        if (paramType.startsWith('vector<int>')) {
                            inputSetup += `        vector<int> ${varName} = parseVectorInt(R"(${cleanInput})");\n`;
                        } else if (paramType.startsWith('vector<string>')) {
                            inputSetup += `        vector<string> ${varName} = parseVectorString(R"(${cleanInput})");\n`;
                        } else if (paramType === 'int' || paramType === 'long long') {
                            inputSetup += `        ${paramType} ${varName} = ${cleanInput};\n`;
                        } else if (paramType === 'string') {
                            inputSetup += `        string ${varName} = ${JSON.stringify(cleanInput)};\n`;
                        } else if (paramType === 'bool') {
                            inputSetup += `        bool ${varName} = ${cleanInput.toLowerCase()};\n`;
                        }
                    });

                    mainCode += inputSetup;

                    const expectedVar = `expected_${i + 1}`;
                    const cppReturnType = this.mapTypeToCpp(returnType);

                    if (cppReturnType.startsWith('vector<int>')) {
                        mainCode += `        vector<int> ${expectedVar} = parseVectorInt(R"(${expectedOutput})");\n`;
                    } else if (cppReturnType.startsWith('vector<string>')) {
                        mainCode += `        vector<string> ${expectedVar} = parseVectorString(R"(${expectedOutput})");\n`;
                    } else if (cppReturnType === 'int' || cppReturnType === 'long long') {
                        mainCode += `        ${cppReturnType} ${expectedVar} = ${expectedOutput};\n`;
                    } else if (cppReturnType === 'string') {
                        mainCode += `        string ${expectedVar} = ${JSON.stringify(expectedOutput)};\n`;
                    } else if (cppReturnType === 'bool') {
                        mainCode += `        bool ${expectedVar} = ${expectedOutput.toLowerCase()};\n`;
                    }

                    mainCode += `
        auto start = chrono::high_resolution_clock::now();
        ${cppReturnType} result = sol.${functionName}(${callParams.join(', ')});
        auto end = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);

        cout << "Execution time: " << duration.count() << " ms" << endl;

        if (duration.count() > TIME_LIMIT_MS) {
            cout << "Status: Time Limit Exceeded" << endl;
        } else if (${this.generateComparison(cppReturnType, 'result', expectedVar)}) {
            cout << "Status: Accepted" << endl;
            passed++;
        } else {
            cout << "Status: Wrong Answer" << endl;
            cout << "Output:   ";
            ${this.generatePrintStatement(cppReturnType, 'result')}
            cout << "Expected: ";
            ${this.generatePrintStatement(cppReturnType, expectedVar)}
        }
        cout << endl;
    }`;
                });

                mainCode += `
    cout << "Results: " << passed << "/" << total << " test cases passed" << endl;
    return 0;
}`;

                return mainCode;
            }

            generateComparison(type, var1, var2) {
                if (type.startsWith('vector')) {
                    return `compareVectors(${var1}, ${var2})`;
                }
                return `${var1} == ${var2}`;
            }

            generatePrintStatement(type, varName) {
                if (type.startsWith('vector')) {
                    return `printVector(${varName}); cout << endl;\n            `;
                }
                return `cout << ${varName} << endl;\n            `;
            }

            mapTypeToCpp(type) {
                const typeMap = {
                    'integer': 'int',
                    'long': 'long long',
                    'double': 'double',
                    'boolean': 'bool',
                    'string': 'string',
                    'character': 'char',
                    'integer[]': 'vector<int>',
                    'string[]': 'vector<string>',
                    'integer[][]': 'vector<vector<int>>',
                    'ListNode': 'ListNode*',
                    'TreeNode': 'TreeNode*'
                };
                return typeMap[type] || type;
            }

            getDefaultValue(type) {
                const cppType = this.mapTypeToCpp(type);
                if (cppType.endsWith('*')) return 'nullptr';
                if (cppType.startsWith('vector')) return '{}';
                if (cppType === 'int' || cppType === 'long long') return '0';
                if (cppType === 'double') return '0.0';
                if (cppType === 'bool') return 'false';
                if (cppType === 'string') return '""';
                if (cppType === 'char') return "'\\0'";
                return '{}';
            }
        }

        class PythonGenerator {
            generate(problemData) {
                const { title, titleSlug, functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                return `# Generated by LeetCode Test Generator
# Problem: ${title}
# Link: https://leetcode.com/problems/${titleSlug}/

import time
import json
from typing import List, Optional

${this.generateStructDefinitions(returnType, parameters)}

class Solution:
    def ${functionName}(self${parameters.length > 0 ? ', ' : ''}${this.generateParameterList(parameters)}) -> ${this.mapTypeToPython(returnType)}:
        # TODO: Implement your solution here
        ${this.getDefaultValue(returnType)}

${this.generateTestMain(problemData)}`;
            }

            generateStructDefinitions(returnType, parameters) {
                const needsListNode = returnType.includes('ListNode') ||
                                    parameters.some(p => p.type.includes('ListNode'));
                const needsTreeNode = returnType.includes('TreeNode') ||
                                    parameters.some(p => p.type.includes('TreeNode'));

                let structs = '';

                if (needsListNode) {
                    structs += `
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    def __eq__(self, other):
        if not other:
            return False
        return self.val == other.val and self.next == other.next`;
                }

                if (needsTreeNode) {
                    structs += `
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right`;
                }

                return structs;
            }

            generateParameterList(parameters) {
                return parameters.map(p => `${p.name}: ${this.mapTypeToPython(p.type)}`).join(", ");
            }

            generateTestMain(problemData) {
                const { functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                let mainCode = `
def run_tests():
    sol = Solution()
    TIME_LIMIT_MS = 2000  # 2 seconds
    passed = 0
    total = ${examples.length}

    print(f"Running {total} test cases...\\n")`;

                examples.forEach((example, i) => {
                    const inputs = example.split('\n');
                    const expectedOutput = expectedOutputs[i] || "None";

                    mainCode += `
    # Test Case ${i + 1}
    print("--- Test Case ${i + 1} ---")`;

                    let callParams = [];
                    inputs.forEach((inputLine, j) => {
                        if (j >= parameters.length) return;

                        const param = parameters[j];
                        const varName = `${param.name}_${i + 1}`;
                        callParams.push(varName);

                        const cleanInput = inputLine.replace(/\r/g, '').trim();
                        mainCode += `\n    ${varName} = ${this.parseInput(param.type, cleanInput)}`;
                    });

                    const expectedVar = `expected_${i + 1}`;
                    mainCode += `\n    ${expectedVar} = ${this.parseInput(returnType, expectedOutput)}`;

                    mainCode += `

    start_time = time.time()
    result = sol.${functionName}(${callParams.join(', ')})
    end_time = time.time()
    duration_ms = (end_time - start_time) * 1000

    print(f"Execution time: {duration_ms:.2f} ms")

    if duration_ms > TIME_LIMIT_MS:
        print("Status: Time Limit Exceeded")
    elif result == ${expectedVar}:
        print("Status: Accepted")
        passed += 1
    else:
        print("Status: Wrong Answer")
        print(f"Output:   {result}")
        print(f"Expected: {${expectedVar}}")
    print()`;
                });

                mainCode += `
    print(f"Results: {passed}/{total} test cases passed")

if __name__ == "__main__":
    run_tests()`;

                return mainCode;
            }

            parseInput(type, input) {
                if (type.includes('[]')) {
                    return input;
                } else if (type === 'string') {
                    return `"${input.replace(/"/g, '\\"')}"`;
                } else if (type === 'boolean') {
                    return input.toLowerCase() === 'true' ? 'True' : 'False';
                }
                return input;
            }

            mapTypeToPython(type) {
                const typeMap = {
                    'integer': 'int',
                    'long': 'int',
                    'double': 'float',
                    'boolean': 'bool',
                    'string': 'str',
                    'character': 'str',
                    'integer[]': 'List[int]',
                    'string[]': 'List[str]',
                    'integer[][]': 'List[List[int]]',
                    'ListNode': 'Optional[ListNode]',
                    'TreeNode': 'Optional[TreeNode]'
                };
                return typeMap[type] || type;
            }

            getDefaultValue(type) {
                if (type.includes('[]')) return 'return []';
                if (type === 'integer' || type === 'long') return 'return 0';
                if (type === 'double') return 'return 0.0';
                if (type === 'boolean') return 'return False';
                if (type === 'string') return 'return ""';
                if (type.includes('Node')) return 'return None';
                return 'pass';
            }
        }

        class JavaGenerator {
            generate(problemData) {
                const { title, titleSlug, functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                return `// Generated by LeetCode Test Generator
// Problem: ${title}
// Link: https://leetcode.com/problems/${titleSlug}/

import java.util.*;

${this.generateStructDefinitions(returnType, parameters)}

class Solution {
    public ${this.mapTypeToJava(returnType)} ${functionName}(${this.generateParameterList(parameters)}) {
        // TODO: Implement your solution here
        return ${this.getDefaultValue(returnType)};
    }
}

${this.generateTestMain(problemData)}`;
            }

            generateStructDefinitions(returnType, parameters) {
                const needsListNode = returnType.includes('ListNode') ||
                                    parameters.some(p => p.type.includes('ListNode'));
                const needsTreeNode = returnType.includes('TreeNode') ||
                                    parameters.some(p => p.type.includes('TreeNode'));

                let structs = '';

                if (needsListNode) {
                    structs += `
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}`;
                }

                if (needsTreeNode) {
                    structs += `
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}`;
                }

                return structs;
            }

            generateParameterList(parameters) {
                return parameters.map(p => `${this.mapTypeToJava(p.type)} ${p.name}`).join(", ");
            }

            generateTestMain(problemData) {
                const { functionName, returnType, parameters, examples, expectedOutputs } = problemData;

                return `
public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();
        int TIME_LIMIT_MS = 2000; // 2 seconds
        int passed = 0;
        int total = ${examples.length};

        System.out.println("Running " + total + " test cases...\\n");

        // TODO: Implement test cases
        // Note: Java test case generation is more complex due to type parsing
        // Consider using the C++ or Python version for more complete testing

        System.out.println("Results: " + passed + "/" + total + " test cases passed");
    }
}`;
            }

            mapTypeToJava(type) {
                const typeMap = {
                    'integer': 'int',
                    'long': 'long',
                    'double': 'double',
                    'boolean': 'boolean',
                    'string': 'String',
                    'character': 'char',
                    'integer[]': 'int[]',
                    'string[]': 'String[]',
                    'integer[][]': 'int[][]',
                    'ListNode': 'ListNode',
                    'TreeNode': 'TreeNode'
                };
                return typeMap[type] || type;
            }

            getDefaultValue(type) {
                if (type.includes('[]')) return 'new ' + this.mapTypeToJava(type) + '{}';
                if (type === 'integer' || type === 'long') return '0';
                if (type === 'double') return '0.0';
                if (type === 'boolean') return 'false';
                if (type === 'string') return '""';
                if (type.includes('Node')) return 'null';
                return 'null';
            }
        }

        // Global instance
        const parser = new LeetCodeParser();

        // Global functions for HTML
        function generateCode() {
            parser.generateCode();
        }

        function copyCode() {
            const code = document.getElementById('outputCode').textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = document.getElementById('copyBtn');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            }).catch(err => {
                alert('Failed to copy code: ' + err);
            });
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'Enter') {
                generateCode();
            }
        });

        // Auto-resize textarea
        document.getElementById('sourceCode').addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.max(200, this.scrollHeight) + 'px';
        });
    </script>
</body>
</html>
